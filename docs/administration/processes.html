<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8">
	<title>5.2. Управление процессами</title>
</head>
<link rel="stylesheet" href="../../styles.css">
<body style="margin: 0px 150px 0px 150px">

<table summary="Header navigation table" width="100%" border="0" cellpadding="0"
cellspacing="0">
<tr>
<th colspan="3" align="center">Администрирование Calmira GNU/Linux</th>
</tr>

<table summary="Footer navigation table" width="100%" border="0" cellpadding="0"
cellspacing="0">
<tr>
<td width="33%" align="left" valign="top"><a href="processes.html"
accesskey="P">Назад</a></td>
<td width="34%" align="center" valign="top"><a href="index.html"
accesskey="H">Домой</a></td>
<td width="34%" align="right" valign="top"><a href="users.html"
accesskey="N">Далее</a></td>

</tr>

<tr>
<td width="33%" align="left" valign="top">Права доступа</td>
<td width="34%" align="center" valign="top">&nbsp;</td>
<td width="33%" align="right" valign="top">Управление пользователями</td>
</tr>
</table>

<hr align="LEFT" width="100%" />

<h1>5.2. Управление процессами</h1>

<h2>Введение</h2>

<p>Процесс в Linux (как и в UNIX) - это программа, которая выполняется в отдельном виртуальном адресном пространстве. Такая абстракция, с помощью которой можно управлять памятью, временем работы процесора и ресурсами ввода/вывода.</p>

<p>Процессы защищены друг от друга и крах одного процесса не повлияет на работу других и всей системы в целом. Один процесс не может прочитать (или записать) данные другого процесса без его разрешения на это, а санкционированное взаимодействие друг с другом разрешено системой.</p>

<p>Процесс состоит из адресного пространства и набора структур данных внутри ядра. Адресное пространство - набор страниц памяти, выделенных ядром для использования процессу.</p>

<p>Для создания процессов используются два системных вызова: <tt>fork()</tt> и <tt>exec</tt>. <tt>fork()</tt> создаёт новое адресное пространство, которое полностью идентично адресному пространству другого процесса. После выполнения <tt>fork()</tt> получается два абсолютно одинаковых процесса - <em>основной</em> и <em>порождённый</em>.</p>

<p>Каждый процесс в системе имеет уникальный идентификатор - <em>Process ID</em>. Этот номер используется ядром и специализированными утилитами для работы с процессами.</p>

<p>Пользователь может управлять поведением процессов, запущенных от его имени. Но только <tt>root</tt> имеет право управления всеми процессами - и его, и других пользователей. Управление процессами производится специально предназначенными для этого утилитами, а так же некоторыми командами оболочки (shell)</p>

<h2>Выполнение процессов</h2>

<p>Есть несколько типов процессов:</p>

<ol>
	<li><b>Процессы переднего плана (foreground)</b>. На переднем плане в каждый момент для текущего терминала может выполняться только один процесс. Однако пользователь может перейти в другой TTY и запустить ещё один. ППП получает информацию с клавиатуры (<tt>stdin</tt>) и выводит результат на экран (<tt>stdout</tt>). Такие процессы иногда называют <em>интерактивными</em>;</li>
	<li><b>Фоновые (автоматические) процессы</b> отвязаны от терминала и не ожидают пользовательского ввода, а командная оболочка не ожидает окончания запущенного процесса, что позволяет пользователю запустить ещё один процесс;</li>
	<li><b>Отложенные процессы</b> в данный момент не выполняются и в данный момент остановлены. Их можно восстановить как на переднем плане, так и в фоне. Возобновление приостановленного процесса не изменит его состояния - он продолжит свою работу с того места, с которого был восстановлен;</li>
	<li><b>Демоны</b> - особый тип фоновых процессов, которые запускаются при старте системы и продолжают работу в виде службы;</li>
</ol>

<h2>PID, PPID</h2>

<p>Ядро назначает каждому процессу уникальный идентификатор (PID - Process Identification). На сегодня Linux использует концепцию пространства имён процесса, которая ещё больше ограничивает способность процессов видеть и влиять друг на друга. Недостаток в том, что процесс может иметь разные PID в зависимости от пространства имён наблюдателя.</p>

<p>Для того, чтобы создать новый процесс, существующий должен клонировать сам себя. Клон может заменить выполняемую программу другой.</p>

<p>Исходный процесс называется <em>родительским</em>, клон - <em>дочерним</em>. Каждый дочерний процесс имеет Parent Process ID (PPID).</p>

<h2>Другие идентификаторы</h2>

<p>Существует ещё несколько идентификаторов процессов, которые пригодятся при администрировании Calmira и других дистрибутивов Linux.</p>

<p>UID (User ID) - это идентификатор пользователя, создавшего данный процесс - копия UID родительского процесса. Менять атрибуты могут только его владелец (тот, кто его создал) и суперпользователь.</p>

<p>EUID (Effective User ID) - текущий пользовательский идентификатор процесса, предназначенный для определения, к каким ресурсам и файлам есть право доступа в данный момент. У большинства процессов значения UID и EUID одинаковые, кроме тех, у которых установлен бит смены идентификатора пользователя <tt>setuid</tt>.</p>

<p>Так же может встречаться довольно редкий и нестандартный параметр FSUID, определяющий возможности работы с ФС, но он используется очень редко.</p>

<p>GID (Group ID) - идентификационный номер группы данного процесса. EGID связан с GID так же, как EUID с UID.</p>

<h2>Жизненный цикл процесса</h2>

<p>Все процессы, кроме <tt>init</tt>, создаются с помощью системного вызова <tt>fork()</tt>. Вызывая эту функцию, процесс создаёт свой дубликат, называемый дочерним процессом (см. предыдущие пункты). Дочерний процесс - копия родительского, но с отличиями:</p>

<ol>
	<li>У дочернего процесса свой PID;</li>
	<li>PPID дочернего процесса равен PPID'у родительского.</li>
</ol>

<p>После вызова <tt>fork()</tt> может посредством системного вызова <tt>wait()</tt>/<tt>waitpid()</tt> приостановить своё выполнение до завершения дочернего процесса, или продолжать свою работу независимо от него. Процесс завершает своё выполнение вызовом функции <tt>exit()</tt></p>
